name: Tekton CI/CD Pipeline

on:
  # D√©clenchement automatique sur push
  push:
    branches:
      - main
      - develop
  
  # D√©clenchement automatique sur Pull Request
  pull_request:
    branches:
      - main
  
  # D√©clenchement manuel avec bouton "Run workflow" dans GitHub
  workflow_dispatch:
    inputs:
      git_revision:
        description: 'Git branch/tag/commit √† build'
        required: false
        default: 'main'

env:
  GIT_URL: ${{ github.server_url }}/${{ github.repository }}
  PROJECT_DIR: demo
  STORAGE_SIZE: 1Gi
  MAVEN_ARGS: clean test

jobs:
  tekton-pipeline:
    name: Ex√©cuter Pipeline Tekton
    runs-on: self-hosted  # Utilise le runner install√© sur votre machine
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configuration kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'
      
      - name: Configuration du contexte Kubernetes
        run: |
          # Utilise le contexte Docker Desktop local
          kubectl config use-context docker-desktop
          kubectl version --client
          kubectl cluster-info
      
      - name: V√©rifier Tekton Pipelines install√©
        run: |
          kubectl get pods -n tekton-pipelines
          kubectl get tasks 2>/dev/null || echo "Aucune task trouv√©e"
      
      - name: Appliquer les Tasks Tekton
        run: |
          kubectl apply -f demo/tekton/tasks/git-clone.yaml
          kubectl apply -f demo/tekton/tasks/maven-test.yaml
      
      - name: Appliquer le Pipeline Tekton
        run: |
          kubectl apply -f demo/tekton/pipeline.yaml
      
      - name: G√©n√©rer et lancer le PipelineRun
        run: |
          # D√©terminer la r√©vision Git √† utiliser
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            GIT_REVISION="${{ github.event.inputs.git_revision }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            GIT_REVISION="${{ github.head_ref }}"
          else
            GIT_REVISION="${{ github.ref_name }}"
          fi
          
          # G√©n√©rer un nom unique pour le PipelineRun
          RUN_NAME="spring-boot-pipeline-run-$(date +%s)"
          
          # Cr√©er le PipelineRun √† partir du template
          cat <<EOF | kubectl apply -f -
          apiVersion: tekton.dev/v1
          kind: PipelineRun
          metadata:
            name: ${RUN_NAME}
            labels:
              app: spring-boot
              ci: github-actions
              git-sha: ${{ github.sha }}
          spec:
            pipelineRef:
              name: spring-boot-test-pipeline
            params:
              - name: repo-url
                value: "${GIT_URL}"
              - name: revision
                value: "${GIT_REVISION}"
              - name: project-dir
                value: "${PROJECT_DIR}"
              - name: maven-args
                value: "${MAVEN_ARGS}"
            workspaces:
              - name: source
                volumeClaimTemplate:
                  spec:
                    accessModes:
                      - ReadWriteOnce
                    resources:
                      requests:
                        storage: ${STORAGE_SIZE}
          EOF
          
          echo "PipelineRun cr√©√©: ${RUN_NAME}"
          echo "RUN_NAME=${RUN_NAME}" >> $GITHUB_ENV
      
      - name: Attendre et afficher les logs
        run: |
          echo "‚è≥ Attente du d√©marrage du PipelineRun..."
          
          # Attendre que le PipelineRun commence (max 2 minutes)
          timeout=120
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            status=$(kubectl get pipelinerun ${{ env.RUN_NAME }} -o jsonpath='{.status.conditions[0].reason}' 2>/dev/null || echo "NotFound")
            if [ "$status" != "NotFound" ] && [ "$status" != "" ]; then
              echo "‚úÖ PipelineRun d√©marr√© avec status: $status"
              break
            fi
            sleep 5
            elapsed=$((elapsed + 5))
          done
          
          # Afficher les logs (n√©cessite tkn CLI ou kubectl logs)
          echo "üìã Logs du PipelineRun:"
          kubectl get pipelinerun ${{ env.RUN_NAME }} -o yaml
          
          # Attendre la fin (max 10 minutes)
          echo "‚è≥ Attente de la fin du PipelineRun..."
          timeout=600
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            status=$(kubectl get pipelinerun ${{ env.RUN_NAME }} -o jsonpath='{.status.conditions[0].status}' 2>/dev/null)
            reason=$(kubectl get pipelinerun ${{ env.RUN_NAME }} -o jsonpath='{.status.conditions[0].reason}' 2>/dev/null)
            
            if [ "$status" == "True" ] && [ "$reason" == "Succeeded" ]; then
              echo "‚úÖ Pipeline r√©ussie !"
              exit 0
            elif [ "$status" == "False" ]; then
              echo "‚ùå Pipeline √©chou√©e !"
              kubectl get pipelinerun ${{ env.RUN_NAME }} -o yaml
              exit 1
            fi
            
            sleep 10
            elapsed=$((elapsed + 10))
          done
          
          echo "‚ö†Ô∏è Timeout - Pipeline toujours en cours"
          exit 1
      
      - name: R√©cup√©rer les r√©sultats des tests
        if: always()
        run: |
          echo "üìä R√©sum√© du PipelineRun:"
          kubectl get pipelinerun ${{ env.RUN_NAME }} -o jsonpath='{.status}' | jq .
      
      - name: Nettoyer les anciens PipelineRuns (optionnel)
        if: always()
        run: |
          # Garder seulement les 10 derniers PipelineRuns
          kubectl get pipelineruns --sort-by=.metadata.creationTimestamp -o name | head -n -10 | xargs -r kubectl delete || true
