name: Tekton CI/CD Pipeline

on:
  # Déclenchement automatique sur push
  push:
    branches:
      - main
      - develop
  
  # Déclenchement automatique sur Pull Request
  pull_request:
    branches:
      - main
  
  # Déclenchement manuel avec bouton "Run workflow" dans GitHub
  workflow_dispatch:
    inputs:
      git_revision:
        description: 'Git branch/tag/commit à build'
        required: false
        default: 'main'

env:
  GIT_URL: ${{ github.server_url }}/${{ github.repository }}
  PROJECT_DIR: demo
  STORAGE_SIZE: 1Gi
  MAVEN_ARGS: clean test

jobs:
  tekton-pipeline:
    name: Exécuter Pipeline Tekton
    runs-on: self-hosted  # Utilise le runner installé sur votre machine
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configuration kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'
      
      - name: Configuration du contexte Kubernetes
        run: |
          # Utilise le contexte Docker Desktop local
          kubectl config use-context docker-desktop
          kubectl version --client
          kubectl cluster-info
      
      - name: Vérifier Tekton Pipelines installé
        run: |
          kubectl get pods -n tekton-pipelines
          try { kubectl get tasks } catch { Write-Host "Aucune task trouvee" }
      
      - name: Appliquer les Tasks Tekton
        run: |
          kubectl apply -f demo/tekton/tasks/git-clone.yaml
          kubectl apply -f demo/tekton/tasks/maven-test.yaml
      
      - name: Appliquer le Pipeline Tekton
        run: |
          kubectl apply -f demo/tekton/pipeline.yaml
      
      - name: Générer et lancer le PipelineRun
        run: |
          # Déterminer la révision Git à utiliser
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $GIT_REVISION = "${{ github.event.inputs.git_revision }}"
          } elseif ("${{ github.event_name }}" -eq "pull_request") {
            $GIT_REVISION = "${{ github.head_ref }}"
          } else {
            $GIT_REVISION = "${{ github.ref_name }}"
          }
          
          # Générer un nom unique pour le PipelineRun
          $RUN_NAME = "spring-boot-pipeline-run-$(Get-Date -Format 'yyyyMMddHHmmss')"
          
          # Créer le PipelineRun
          @"
          apiVersion: tekton.dev/v1
          kind: PipelineRun
          metadata:
            name: $RUN_NAME
            labels:
              app: spring-boot
              ci: github-actions
              git-sha: ${{ github.sha }}
          spec:
            pipelineRef:
              name: spring-boot-test-pipeline
            params:
              - name: repo-url
                value: "${{ github.server_url }}/${{ github.repository }}"
              - name: revision
                value: "$GIT_REVISION"
              - name: project-dir
                value: "demo"
              - name: maven-args
                value: "clean test"
            workspaces:
              - name: source
                volumeClaimTemplate:
                  spec:
                    accessModes:
                      - ReadWriteOnce
                    resources:
                      requests:
                        storage: 1Gi
          "@ | kubectl apply -f -
          
          Write-Host "PipelineRun cree: $RUN_NAME"
          Write-Output "RUN_NAME=$RUN_NAME" >> $env:GITHUB_ENV
      
      - name: Attendre et afficher les logs
        run: |
          Write-Host "Attente du demarrage du PipelineRun..."
          
          # Attendre que le PipelineRun commence (max 2 minutes)
          $timeout = 120
          $elapsed = 0
          while ($elapsed -lt $timeout) {
            $status = kubectl get pipelinerun $env:RUN_NAME -o jsonpath='{.status.conditions[0].reason}' 2>$null
            if ($status -and $status -ne "") {
              Write-Host "PipelineRun demarre avec status: $status"
              break
            }
            Start-Sleep -Seconds 5
            $elapsed += 5
          }
          
          # Afficher les infos du PipelineRun
          Write-Host "Logs du PipelineRun:"
          kubectl get pipelinerun $env:RUN_NAME -o yaml
          
          # Attendre la fin (max 10 minutes)
          Write-Host "Attente de la fin du PipelineRun..."
          $timeout = 600
          $elapsed = 0
          while ($elapsed -lt $timeout) {
            $status = kubectl get pipelinerun $env:RUN_NAME -o jsonpath='{.status.conditions[0].status}' 2>$null
            $reason = kubectl get pipelinerun $env:RUN_NAME -o jsonpath='{.status.conditions[0].reason}' 2>$null
            
            if ($status -eq "True" -and $reason -eq "Succeeded") {
              Write-Host "Pipeline reussie!"
              exit 0
            } elseif ($status -eq "False") {
              Write-Host "Pipeline echouee!"
              kubectl get pipelinerun $env:RUN_NAME -o yaml
              exit 1
            }
            
            Start-Sleep -Seconds 10
            $elapsed += 10
          }
          
          Write-Host "Timeout - Pipeline toujours en cours"
          exit 1
      
      - name: Récupérer les résultats des tests
        if: always()
        run: |
          Write-Host "Resume du PipelineRun:"
          kubectl get pipelinerun $env:RUN_NAME -o jsonpath='{.status}' | ConvertFrom-Json | ConvertTo-Json
      
      - name: Nettoyer les anciens PipelineRuns (optionnel)
        if: always()
        run: |
          # Garder seulement les 10 derniers PipelineRuns
          $pipelineruns = kubectl get pipelineruns --sort-by=.metadata.creationTimestamp -o name
          if ($pipelineruns.Count -gt 10) {
            $toDelete = $pipelineruns | Select-Object -First ($pipelineruns.Count - 10)
            if ($toDelete) {
              $toDelete | ForEach-Object { kubectl delete $_ }
            }
          }
